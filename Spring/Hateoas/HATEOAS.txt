HATEOAS

Fornecer links relevantes de acordo com os dados cadastrados
Para o suporte do Hateoas use o Mokito e o JUnit

>>>Hateoas é necessário para a aplicação ser RESTFUL<<<

> Coloque a seguinte dependência no POM.XML
		<dependency>
			<groupId>org.springframework.hateoas</groupId>
			<artifactId>spring-hateoas</artifactId>
		</dependency>

> Na classe PersonDto, faça ela extender a classe RepresentationModel do a biblioteca do hateoas, e diga que o tipo da RepresentationModel é PersonDTO

> No service, faça as seguinte importações:
	import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;
	import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;

> Adicione as modificações no método findById(as modificações estao a partir de dto.add())
	public PersonDTO findById(Long id) {
		logger.info("Finding one Person!");		
		var entity = repository.findById(id).orElseThrow(() -> new ResourceNotFoundException("No records found for this ID"));
		//convertendo para personDTO
		var dto = parseObject(entity, PersonDTO.class);
		dto.add(linkTo(methodOn(PersonController.class)//diz que o objeto terá um link para um metodo DE PersonController
				.findById(id))// qual metodo? findById
				.withSelfRel()//diz o papel do link, e esse metodo diz que seria o link principal
				.withType("GET"));//diz que o tipo do link é um GET
		return dto;
	}

> Isso fará retornar:
	---
	id: 13
	firstName: "Neil"
	lastName: "Armstrong"
	address: "Wapakoneta - US"
	gender: "Male"
	links:
    		- rel: "self"
      		href: "http://localhost:8080/api/person/v1/13"
      		type: "GET"

> Agora, é necessário notar que seria mais eficiente se a adição desse link fosse um método a parte, portando o dto.add() irá virar um método
	então na linha dto.add(), coloque
		addHateoasLinks(id,dto);
	e crie um método
	
		private static void addHateoasLinks(Long id, PersonDTO dto) {
			dto.add(linkTo(methodOn(PersonController.class)//diz que o objeto terá um link para ummetodo DE PersonController
				.findById(id))// qual metodo? findById
				.withSelfRel()//diz o papel do link, e esse metodo diz que seria o link principal(autoLink)
				.withType("GET"));//diz que o tipo do link é um GET
		
			dto.add(linkTo(methodOn(PersonController.class)
				.delete(id))
				.withRel("delete")
				.withType("DELETE"));
		
			dto.add(linkTo(methodOn(PersonController.class)
				.findById())
				.withRel("findById")
				.withType("GET"));
		
			dto.add(linkTo(methodOn(PersonController.class)
				.create(dto))
				.withRel("create")
				.withType("POST"));
		
			dto.add(linkTo(methodOn(PersonController.class)
				.updatePerson(dto))
				.withRel("update")
				.withType("PUT"));
			}

> Isso irá retornar:
	---
	id: 13
	firstName: "Neil"
	lastName: "Armstrong"
	address: "Wapakoneta - US"
	gender: "Male"
	links:
    		- rel: "self"
      		href: "http://localhost:8080/api/person/v1/13"
      		type: "GET"
    		- rel: "delete"
      		href: "http://localhost:8080/api/person/v1/13"
      		type: "DELETE"
    		- rel: "findById"
      		href: "http://localhost:8080/api/person/v1"
      		type: "GET"
    		- rel: "create"
      		href: "http://localhost:8080/api/person/v1"
      		type: "POST"
    		- rel: "update"
      		href: "http://localhost:8080/api/person/v1"
      		type: "PUT"

> Adicione os links Hateoas nos outros métodos:

	public PersonDTO create(PersonDTO person) {
		logger.info("Create one Person!");
		
		//convertendo de DTO para person(entidade)
		var entity = parseObject(person, Person.class);
		
		//salva e converte para DTO
		var dto = parseObject( repository.save(entity), PersonDTO.class);
		addHateoasLinks(dto); //Adicione essa linha
		return dto;
	}

	public List<PersonDTO> findAll() {
		
		logger.info("Find all People!");
		
		//converte para personDTO
		var persons=  parseListObjects(repository.findAll(), PersonDTO.class);
		persons.forEach(this:: addHateoasLinks);//para cada objeto que vier :: mande para esse metodo
		return persons;
	
	}

	public PersonDTO update(PersonDTO person) {
		logger.info("Updating one Person!");
			
		Person entity = repository.findById(person.getId())
				.orElseThrow(() -> new ResourceNotFoundException("No records found for this ID"));
		entity.setFirstName(person.getFirstName());
		entity.setLastName(person.getLastName());
		entity.setAddress(person.getAddress());
		entity.setGender(person.getGender());
		
		var dto = parseObject( repository.save(entity), PersonDTO.class);
		addHateoasLinks(dto);
		return dto;
	}

	//Lembrando que delete não precisa

> Mockito - https://site.mockito.org/

* É um framework de testes e spy
* Ele simula a instancia de classes e o comportamento de métodos
* Ao mockar uma dependência com Mokito, eu faço com que a classe que irá ser testada, simule o
método testado e suas depencias
* Durante o mock, eu posso configurar o retorno e as ações de acordo com as necessidades do teste

* Principais funções:
* Fazer mocks - ela cria a instancia de uma classe, porem, mockada. Se ele chamar um método, não ira chamar o método real(a não ser que queira)

* Spy - Criar uma instancia da classe que voce pode mockar ou chamar métodos reais - alternativa a objectsMocks
* Inject Mocks - Cria uma instancia e injeta as dependências necessárias que estão anotadas com @Mock
* Verify - Verifica a quantidade de vezes e quais parâmetros utilizados para acessar determinado método
* When - após um mock ser criado voce pode configurar as ações da chamada e qual o retorno que vai receber
* Matchers - Permite que verifique por meio de matchers os argumentos como N-Objects, N-Strings etc

** Não precisa adicionar a dependencia do Mockito, porque ela ja existe dentro da dependencia padrao do Spring Boot **
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

> Usando JUnit, criaremos os metodos de testes. O setup/@Before é o que irá acontecer antes do mock. 
> Crie a classe PersonServiceTest dentro da pasta de testes do spring.

	@TestInstance(TestInstance.Lifecycle.PER_CLASS)//ciclo de vida do junit, os objetos irao durar apenas para essa classe
	public class PersonServiceTest {

		@BeforeEach
		void setUp() {
		
		}
	
	
		@Test
		void findById() {
		
		}
	
		@Test
		void create() {
			
		}
	
		@Test
		void update() {
		
		}
	
		@Test
		void delete() {
		
		}
	
		@Test
		void findAll() {
		
		}
	}


> Metodo findById da classe PersonService com explicação nos comentarios 

	/*
	 * Primeiro o objeto input retorna um person que vai para dentro de person.
	 * assim, voce seta o id manualmente (1L)
	 * repository é um objeto mockado, isso signific aque ele nao envia para o banco de dados
	 * a parte do when é:
	 * quando o findById(do repository) for chamado com 1L, retorne esse objeto person dentro de um Optional
	 * entao, na var result tem o person
	 * cada asserNotNull verifica se tal coisa nao esta nula
	 * */
	//no geral, o metodo cria o mock e verifica se cada campo está preenchidom se nao estiver, da um erro
	@Test
	void findById() {
		Person person = input.mockEntity(1);//uma instancia
		person.setId(1L);
		when(repository.findById(1L))//when precisa ser importado manualmente com import static org.mockito.Mockito.when;
		.thenReturn(Optional.of(person));
		
		var result = service.findById(1L);
		
		//assertNotNull precisa ser importado estaticamente com import static org.junit.jupiter.api.Assertions.assertNotNull;
		assertNotNull(result); // testa se o retorno não é nulo
		assertNotNull(result.getId()); // testa se o id não é nulo
		assertNotNull(result.getLinks());  // testa se os links não são nulos
		assertNotNull(result.getLinks() //retorna uma lista de links (HATEOAS)
				.stream()// transofmra em um tipo de lista que pode usar anyMatch(esse metodo retorna boolean)
				.anyMatch(link -> link.getRel().value().equals("self")//verifica se o rel é igual a self (rel esta no retorno das listas, verificar no postman)
						&& link.getHref().endsWith("/api/person/v1/1")//verifica se o link termina com
						&& link.getType().equals("GET")));//verifica se o tipo é GET
		
		assertNotNull(result.getLinks() 
				.stream()
				.anyMatch(link -> link.getRel().value().equals("findAll")
						&& link.getHref().endsWith("/api/person/v1")
						&& link.getType().equals("GET")));
		
		assertNotNull(result.getLinks() 
				.stream()
				.anyMatch(link -> link.getRel().value().equals("create")
						&& link.getHref().endsWith("/api/person/v1")
						&& link.getType().equals("POST")));
		
		assertNotNull(result.getLinks() 
				.stream()
				.anyMatch(link -> link.getRel().value().equals("update")
						&& link.getHref().endsWith("/api/person/v1")
						&& link.getType().equals("PUT")));
		
		assertNotNull(result.getLinks() 
				.stream()
				.anyMatch(link -> link.getRel().value().equals("delete")
						&& link.getHref().endsWith("/api/person/v1/1")
						&& link.getType().equals("DELETE")));
		
		//o metodo assertEquals se importa com import static org.junit.jupiter.api.Assertions.assertEquals;
		//assertEquals(o que se espera, o que tem)
		//lembrando que Address Test1 seria parte do mock que se faz na classe MockPerson
		assertEquals("Address Test1", result.getAddress());
		assertEquals("First Name Test1", result.getFirstName());
		assertEquals("Last Name Test1", result.getLastName());
		assertEquals("Female", result.getGender());

	}


>>> Verificar os outros metodos no proprio programa(que seguem a mesma estrutura do de cima), esta tudo bem documentado



